import { test, expect, Page } from '@playwright/test';
import { navigateSSR, waitForHydration } from '../../helpers/ssr-helpers';

test.describe('Video Streaming E2E Tests', () => {
  let page: Page;

  test.beforeEach(async ({ context }) => {
    page = await context.newPage();
    
    // Navigate with SSR support
    await navigateSSR(page, '/', {
      expectedStatus: [200, 307],
      timeout: 45000
    });
    await waitForHydration(page);
    
    // Set up any required auth tokens
    await page.evaluate(() => {
      localStorage.setItem('authToken', 'test-streaming-token');
      localStorage.setItem('currentUser', JSON.stringify({
        id: 'test-user',
        email: 'streamer@bigfootlive.io',
        firstName: 'Test',
        lastName: 'Streamer',
        role: 'streamer'
      }));
    });
  });

  test.describe('Stream Setup', () => {
    test('should access streaming dashboard', async () => {
      await page.goto('/streaming');
      
      // Verify streaming page loads
      await expect(page).toHaveTitle(/Streaming/i);
      
      // Check for key streaming UI elements
      await expect(page.locator('h1')).toContainText(/Stream/i);
    });

    test('should display stream configuration options', async () => {
      await page.goto('/streaming');
      
      // Check for stream settings
      const streamTitle = page.locator('input[name="streamTitle"], input[placeholder*="title"]');
      const streamDescription = page.locator('textarea[name="description"], textarea[placeholder*="description"]');
      
      // Verify configuration fields exist
      await expect(streamTitle.or(page.locator('text=Stream Title')).first()).toBeVisible();
    });

    test('should show RTMP ingest URL', async () => {
      await page.goto('/streaming');
      
      // Look for RTMP URL display
      const rtmpUrl = page.locator('text=/rtmp[s]?:\/\//i');
      const streamKey = page.locator('input[type="password"], input[name*="key"], text=/stream.*key/i');
      
      // At least one streaming endpoint indicator should be visible
      await expect(rtmpUrl.or(streamKey).or(page.locator('text=Stream URL')).first()).toBeVisible();
    });
  });

  test.describe('Live Streaming', () => {
    test('should navigate to live streaming page', async () => {
      await page.goto('/streaming/live');
      
      // Wait for page to load
      await page.waitForLoadState('networkidle');
      
      // Verify we're on the live streaming page
      await expect(page).toHaveURL(/.*\/streaming\/live/);
    });

    test('should display video player container', async () => {
      await page.goto('/streaming/live');
      
      // Look for video player elements
      const videoPlayer = page.locator('video, iframe, div[class*="player"], div[id*="player"], div[class*="video"]');
      
      // At least one video container should exist
      await expect(videoPlayer.first()).toBeVisible();
    });

    test('should show streaming controls', async () => {
      await page.goto('/streaming/live');
      
      // Check for streaming control buttons
      const playButton = page.locator('button[aria-label*="play"], button[title*="play"], button:has-text("Play")');
      const volumeControl = page.locator('[aria-label*="volume"], [title*="volume"], input[type="range"]');
      const fullscreenButton = page.locator('button[aria-label*="fullscreen"], button[title*="fullscreen"]');
      
      // At least some controls should be present
      const controls = playButton.or(volumeControl).or(fullscreenButton);
      await expect(controls.first()).toBeVisible();
    });

    test('should display stream status indicators', async () => {
      await page.goto('/streaming/live');
      
      // Look for status indicators
      const liveIndicator = page.locator('text=/live/i, .live-indicator, [class*="live"], [class*="status"]');
      const viewerCount = page.locator('text=/viewer/i, text=/watching/i, [class*="viewer"]');
      
      // Status information should be visible
      await expect(liveIndicator.or(viewerCount).first()).toBeVisible();
    });
  });

  test.describe('Stream Playback', () => {
    test('should handle HLS stream playback', async () => {
      await page.goto('/streaming/live');
      
      // Check for HLS.js or native HLS support
      const hasHLS = await page.evaluate(() => {
        return typeof (window as any).Hls !== 'undefined' || 
               document.querySelector('video')?.canPlayType('application/vnd.apple.mpegurl') === 'maybe';
      });
      
      expect(hasHLS).toBeTruthy();
    });

    test('should support adaptive bitrate streaming', async () => {
      await page.goto('/streaming/live');
      
      // Look for quality selector
      const qualitySelector = page.locator('[aria-label*="quality"], button:has-text("Auto"), select:has(option:has-text("720p"))');
      
      // Quality options should be available (or auto mode)
      await expect(qualitySelector.first()).toBeVisible();
    });

    test('should handle stream errors gracefully', async () => {
      await page.goto('/streaming/live');
      
      // Simulate network error
      await page.route('**/*.m3u8', route => route.abort());
      
      // Reload to trigger error
      await page.reload();
      
      // Should show error message or retry option
      const errorMessage = page.locator('text=/error|retry|unavailable|offline/i');
      await expect(errorMessage.first()).toBeVisible({ timeout: 15000 });
    });
  });

  test.describe('Interactive Features', () => {
    test('should display chat interface', async () => {
      await page.goto('/streaming/live');
      
      // Look for chat elements
      const chatContainer = page.locator('[class*="chat"], [id*="chat"], div:has-text("Chat")');
      const chatInput = page.locator('input[placeholder*="message"], textarea[placeholder*="chat"], input[placeholder*="say"]');
      
      // Chat interface should be present
      await expect(chatContainer.or(chatInput).first()).toBeVisible();
    });

    test('should show viewer reactions', async () => {
      await page.goto('/streaming/live');
      
      // Look for reaction buttons
      const reactions = page.locator('button[aria-label*="like"], button[aria-label*="heart"], button:has-text("👍")');
      
      // Reaction options should be available
      await expect(reactions.first()).toBeVisible();
    });

    test('should display stream analytics', async () => {
      await page.goto('/streaming/live');
      
      // Look for analytics displays
      const analytics = page.locator('text=/bitrate|fps|latency|buffer/i');
      
      // At least some analytics should be visible
      await expect(analytics.first()).toBeVisible();
    });
  });

  test.describe('Mobile Responsiveness', () => {
    test('should be mobile responsive', async () => {
      // Set mobile viewport
      await page.setViewportSize({ width: 375, height: 667 });
      
      await page.goto('/streaming/live');
      
      // Video player should still be visible
      const videoContainer = page.locator('video, iframe, div[class*="player"]');
      await expect(videoContainer.first()).toBeVisible();
      
      // Check if layout adapts
      const mobileMenu = page.locator('button[aria-label*="menu"], [class*="mobile"]');
      await expect(mobileMenu.first()).toBeVisible();
    });

    test('should support landscape orientation', async () => {
      // Set landscape viewport
      await page.setViewportSize({ width: 667, height: 375 });
      
      await page.goto('/streaming/live');
      
      // Video should expand in landscape
      const videoContainer = page.locator('video, iframe, div[class*="player"]');
      const box = await videoContainer.first().boundingBox();
      
      // Video should use most of viewport width
      expect(box?.width).toBeGreaterThan(600);
    });
  });

  test.describe('Performance', () => {
    test('should load stream quickly', async () => {
      const startTime = Date.now();
      
      await page.goto('/streaming/live');
      await page.waitForLoadState('networkidle');
      
      const loadTime = Date.now() - startTime;
      
      // Page should load within 5 seconds
      expect(loadTime).toBeLessThan(5000);
    });

    test('should handle concurrent viewers', async ({ context }) => {
      // Simulate multiple viewers
      const viewers = await Promise.all([
        context.newPage(),
        context.newPage(),
        context.newPage()
      ]);
      
      // All viewers navigate to stream
      await Promise.all(
        viewers.map(viewer => viewer.goto('/streaming/live'))
      );
      
      // All should load successfully
      for (const viewer of viewers) {
        await expect(viewer).toHaveURL(/.*\/streaming\/live/);
      }
      
      // Clean up
      await Promise.all(viewers.map(v => v.close()));
    });
  });

  test.describe('Stream Management', () => {
    test('should allow starting a stream', async () => {
      await page.goto('/streaming');
      
      // Look for start stream button
      const startButton = page.locator('button:has-text("Start"), button:has-text("Go Live")');
      
      if (await startButton.isVisible()) {
        await startButton.click();
        
        // Should navigate or show stream started
        await expect(page.locator('text=/live|streaming|started/i').first()).toBeVisible();
      }
    });

    test('should allow stopping a stream', async () => {
      await page.goto('/streaming');
      
      // Look for stop stream button
      const stopButton = page.locator('button:has-text("Stop"), button:has-text("End")');
      
      if (await stopButton.isVisible()) {
        // Click would stop the stream
        await expect(stopButton).toBeEnabled();
      }
    });

    test('should show stream history', async () => {
      await page.goto('/streaming');
      
      // Look for past streams or history section
      const history = page.locator('text=/history|past|previous|recorded/i');
      
      // History section should be accessible
      await expect(history.first()).toBeVisible();
    });
  });

  test.afterEach(async () => {
    await page.close();
  });
});

// Additional test for RTMP ingest validation
test.describe('RTMP Ingest', () => {
  test('should validate RTMP endpoint', async ({ request }) => {
    // Check if RTMP endpoint is configured
    const response = await request.get('/api/streaming/rtmp-config').catch(() => null);
    
    if (response && response.ok()) {
      const config = await response.json();
      
      // Should have RTMP URL
      expect(config).toHaveProperty('rtmpUrl');
      expect(config.rtmpUrl).toMatch(/rtmp[s]?:\/\//);
    }
  });

  test('should provide stream key', async ({ page }) => {
    await page.goto('/streaming');
    
    // Look for stream key field
    const streamKey = page.locator('input[type="password"], input[name*="key"]');
    
    if (await streamKey.isVisible()) {
      // Should have a way to reveal/copy stream key
      const revealButton = page.locator('button[aria-label*="show"], button[aria-label*="copy"]');
      await expect(revealButton.first()).toBeVisible();
    }
  });
});

// Test for CDN distribution
test.describe('CDN Distribution', () => {
  test('should serve video through CDN', async ({ page }) => {
    await page.goto('/streaming/live');
    
    // Intercept video requests
    const videoRequests: string[] = [];
    page.on('request', request => {
      if (request.url().includes('.m3u8') || request.url().includes('.ts')) {
        videoRequests.push(request.url());
      }
    });
    
    await page.waitForTimeout(2000);
    
    // Should have CDN URLs
    const cdnRequests = videoRequests.filter(url => 
      url.includes('cloudfront') || 
      url.includes('cdn') || 
      url.includes('edge')
    );
    
    // At least some requests should go through CDN
    expect(cdnRequests.length).toBeGreaterThan(0);
  });
});